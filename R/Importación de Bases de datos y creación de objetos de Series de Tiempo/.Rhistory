}
}
} else {
Di <- matrix(0, nrow = 0L, ncol = k)
}
## 2.2 Parte AR (p lags)
p_i <- ars$p[i]
if (p_i > 0L) {
if (is.null(ri$phi)) {
Phi_i <- matrix(0, nrow = p_i * k, ncol = k)
} else {
if (length(ri$phi) < p_i) {
stop(sprintf("In regime %d 'phi' must be a list of length at least p[%d]=%d",
i, i, p_i),
call. = FALSE)
}
Phi_list <- lapply(seq_len(p_i), function(j) {
M <- as.matrix(ri$phi[[j]])
if (!all(dim(M) == c(k, k))) {
stop(sprintf("In regime %d, lag %d, 'phi' must be a %dx%d matrix",
i, j, k, k),
call. = FALSE)
}
M
})
Phi_i <- do.call(rbind, Phi_list)
}
} else {
Phi_i <- matrix(0, nrow = 0L, ncol = k)
}
## 2.3 Parte exógena (q lags, r variables)
q_i <- ars$q[i]
if (q_i > 0L) {
if (r <= 0L) {
stop("Argument 'r' (number of exogenous variables) must be > 0 when some q > 0",
call. = FALSE)
}
if (is.null(ri$beta)) {
Beta_i <- matrix(0, nrow = q_i * r, ncol = k)
} else {
if (length(ri$beta) < q_i) {
stop(sprintf("In regime %d 'beta' must be a list of length at least q[%d]=%d",
i, i, q_i),
call. = FALSE)
}
Beta_list <- lapply(seq_len(q_i), function(j) {
B <- as.matrix(ri$beta[[j]])
if (!all(dim(B) == c(r, k))) {
stop(sprintf("In regime %d, lag %d, 'beta' must be a %dx%d matrix",
i, j, r, k),
call. = FALSE)
}
B
})
Beta_i <- do.call(rbind, Beta_list)
}
} else {
Beta_i <- matrix(0, nrow = 0L, ncol = k)
}
## 2.4 Parte asociada a la variable de umbral (d lags, escalar por ecuación)
d_i <- ars$d[i]
if (d_i > 0L) {
if (is.null(ri$delta)) {
Delta_i <- matrix(0, nrow = d_i, ncol = k)
} else {
Delta_i <- as.matrix(ri$delta)
if (!all(dim(Delta_i) == c(d_i, k))) {
stop(sprintf("In regime %d 'delta' must be a %dx%d matrix",
i, d_i, k),
call. = FALSE)
}
}
} else {
Delta_i <- matrix(0, nrow = 0L, ncol = k)
}
## 2.5 Construimos Theta en el orden exacto que usa simtar:
##     [determinísticos; AR; exógenas; d-lags umbral]
Theta_i <- rbind(Di, Phi_i, Beta_i, Delta_i)
expected_rows <- deterministic + ars$p[i] * k + ars$q[i] * r + ars$d[i]
if (nrow(Theta_i) != expected_rows) {
stop(sprintf("Internal error: regime %d, location has %d rows but expected %d",
i, nrow(Theta_i), expected_rows),
call. = FALSE)
}
## 2.6 Matriz de covarianza
Sigma_i <- as.matrix(ri$Sigma)
if (!all(dim(Sigma_i) == c(k, k))) {
stop(sprintf("In regime %d 'Sigma' must be a %dx%d covariance matrix", i, k, k),
call. = FALSE)
}
parms[[i]] <- list(location = Theta_i,
scale    = Sigma_i)
}
parms
}
####Parámetros Multivariado----
library(mtarm)
## Estructura de rezagos
ars.obj <- ars(nregim = 2, p = c(2, 1), q = c(1, 1), d = c(1, 1))
k        <- 2      # dimensión de Y_t
r        <- 1      # una exógena
Intercept <-TRUE
trend     <- "linear"
nseason   <- 4     # p.ej. trimestres
## ----------------- Régimen 1 -----------------
## determinísticos:
##   - 1 fila: intercepto
##   - 1 fila: tendencia lineal
##   - 3 filas: dummies estacionales (4-1)
#reg1_det <- rbind(
#  c(0.5,  0.0),   # intercepto para Y1, Y2
#  c(0.01, 0.02),  # pendiente de tendencia
#  c(0.0,  0.0),   # dummy 1
#  c(0.1, -0.1),   # dummy 2
#  c(-0.1, 0.1)    # dummy 3
#)
reg1_det <- rbind(
c(0.0,  0.0),   # intercepto para Y1, Y2
c(0.00, 0.00),  # pendiente de tendencia
c(1.0,  10.0),   # dummy 1
c(2.0, 20.0),   # dummy 2
c(3.0, 30.0)    # dummy 3
)
## AR: p1 = 2, necesitas 2 matrices 2x2
reg1_phi <- list(
matrix(c(0.50,  0.10,
0.00,  0.30), nrow = 2, byrow = TRUE),  # lag 1
matrix(c(-0.20, 0.00,
0.00, -0.10), nrow = 2, byrow = TRUE)   # lag 2
)
## exógenas: q1 = 1, r = 1, matriz 1x2
reg1_beta <- list(
matrix(c(0.30, -0.20), nrow = 1)   # efecto de X_{t-1} en Y1, Y2
)
## d1 = 1 rezago de la variable umbral
reg1_delta <- matrix(c(0.10, 0.00), nrow = 1)  # efecto de Z_{t-1} en cada ecuación
## covarianza
reg1_Sigma <- matrix(c(1.0, 0.3,
0.3, 1.5), nrow = 2, byrow = TRUE)
reg1 <- regime_spec(det   = reg1_det,
phi   = reg1_phi,
beta  = reg1_beta,
delta = reg1_delta,
Sigma = reg1_Sigma)
## ----------------- Régimen 2 -----------------
#reg2_det <- rbind(
#  c(-0.5, 0.5),
#  c(0.00, 0.01),
#  c(0.2,  0.0),
#  c(0.0, -0.2),
#  c(0.0,  0.0)
#)
reg2_det <- rbind(
c(10.0, 20.0),
c(0.0, 0.0),
c(1.0,  1.0),
c(2.0, 2.0),
c(3.0,  3.0)
)
## p2 = 1 -> solo una matriz 2x2
reg2_phi <- list(
matrix(c(0.20, 0.00,
0.10, 0.40), nrow = 2, byrow = TRUE)  # lag 1
)
## q2 = 1, r = 1 -> 1x2
reg2_beta <- list(
matrix(c(-0.10, 0.20), nrow = 1)
)
## d2 = 1
reg2_delta <- matrix(c(-0.05, 0.05), nrow = 1)
reg2_Sigma <- matrix(c(0.7, 0.1,
0.1, 0.8), nrow = 2, byrow = TRUE)
reg2 <- regime_spec(det   = reg2_det,
phi   = reg2_phi,
beta  = reg2_beta,
delta = reg2_delta,
Sigma = reg2_Sigma)
## ----------------- Construir parms -----------------
parms <- tar_parms(
ars        = ars.obj,
k          = k,
Intercept  = Intercept,
trend      = trend,
nseason    = nseason,
r          = r,
regimes    = list(reg1, reg2)
)
###Simular
#set.seed(123)
n     <- 2000
delay <- 1
ps <- max(ars.obj$p, ars.obj$q, ars.obj$d, delay)
## serie umbral Z_t (para TAR; si fuera SETAR, usarías setar = 1,2,...)
t.series <- rnorm(n + ps)
## exógena X_t de dimensión r = 1
ex.series <- matrix(rnorm((n + ps) * r), nrow = n + ps, ncol = r)
sim <- simtar(
n         = n,
k         = k,
ars       = ars.obj,
Intercept = Intercept,
trend     = trend,
nseason   = nseason,
parms     = parms,
delay     = delay,
thresholds = 0,       # umbral para definir regímenes
t.series  = t.series, # serie de umbral (TAR)
ex.series = ex.series,
dist      = "Gaussian"
)
head(sim)
#salida<-mtar(~Y1+Y2|t.series|X1,data=sim,nseason=4, Intercept=TRUE,trend="linear",dist="Gaussian",ars=ars.obj,n.burnin=2000,n.sim=3000, n.thin=2)
#summary(salida)
salida<-mtar(~Y1+Y2|t.series|X1,data=sim,nseason=4, Intercept=TRUE,trend="linear",dist="Gaussian",ars=ars.obj,
n.burnin=2000,n.sim=3000, n.thin=2)
summary(salida)
knitr::opts_chunk$set(echo = TRUE)
library(TSstudio)
tipos88 <- read.table("tipos88.dat", quote="\"", comment.char="")
setwd("~/Documents/GitHub/TimeSeries/Series-Univariadas/R/Importación de Bases de datos y creación de objetos de Series de Tiempo")
library(TSstudio)
tipos88 <- read.table("tipos88.dat", quote="\"", comment.char="")
Intanual=tipos88$V5  #Tipo de interés Anual
plot(as.ts(Intanual))
knitr::opts_chunk$set(echo = TRUE)
tipos88  = read.table("tipos88.dat", quote="\"", comment.char="")
Intanual = ts(tipos88$V5) #Tipo de interés Anual
plot(Intanual,main="Interés anual",ylab="")
camrelintanual = log(Intanual[2:length(Intanual)]/Intanual[1:(length(Intanual)-1)])
sercamrelint   = ts(camrelintanual,start=c(1988,01),frequency=12)
time(sercamrelint)[1:12]
plot(sercamrelint,main="Cambios relativos")
plot.ts(sercamrelint) # Usamos .ts para especificar que es para objetos ts, pero en la practica no es necesario
acf(sercamrelint,lag.max = 20)
acf(sercamrelint,ci.type='ma')
acf(sercamrelint,type='partial')
acf(sercamrelint,lag.max = 20)
acf(sercamrelint,ci.type='ma')
acf(sercamrelint,type='partial')
acf(sercamrelint,lag.max = 20)
acf(sercamrelint,ci.type='ma')
acf(sercamrelint,type='partial')
acf(sercamrelint,lag.max = 20)
acf(sercamrelint,ci.type='ma')
acf(sercamrelint,type='partial')
str(sercamrelint) # Así vemos la estructura de la serie de tiempo y los primeros datos que la componen
head(time(sercamrelint),20) # Así vemos las marcas de tiempo
head(cycle(sercamrelint),15) # Así vemos las posiciones de acuerdo al periodo de la serie
frequency(sercamrelint) # Así vemos la frecuencia de la serie
deltat(sercamrelint)# Así vemos el salto que hay entre las marcas de tiempo, en este caso es 1/12
library(TSstudio)
ts_info(sercamrelint)
data(EURO_Brent)
library(zoo)
ts_info(EURO_Brent)
class(EURO_Brent)# Es un objeto zoo y es una serie regularmente espaciada zooreg
head(index(EURO_Brent)) # Así vemos los primeros índices de la serie
class(index(EURO_Brent)) # Así vemos la clase de los índices de la serie
attributes(index(EURO_Brent)) #??
index(EURO_Brent) <- as.Date(index(EURO_Brent))
head(EURO_Brent)
class(index(EURO_Brent))
data(US_indicators)
str(US_indicators)
Ventas_vehiculos1 = zoo(x=US_indicators$`Vehicle Sales`,frequency=12)  #Crea un objeto zoo de frecuencia 12, note que el crea el índice automáticamente
class(Ventas_vehiculos1)
frequency(Ventas_vehiculos1)
head(Ventas_vehiculos1)
class(index(Ventas_vehiculos1))
Ventas_vehiculos2 = zoo(x = US_indicators$`Vehicle Sales`,
order.by = US_indicators$Date,
frequency = 12)
head(Ventas_vehiculos2)
class(Ventas_vehiculos2)
class(index(Ventas_vehiculos2))
plot(Ventas_vehiculos1)
plot(Ventas_vehiculos2)
is.regular(Ventas_vehiculos1,strict = TRUE)
is.regular(Ventas_vehiculos1,strict = FALSE)
is.regular(Ventas_vehiculos2,strict = TRUE) # Por contener año bisiesto no es estrictamente una serie regualr.
is.regular(Ventas_vehiculos2,strict = FALSE)
library(xts)
library(readxl)
data("Michigan_CS")###De TSstudio
ts_info(Michigan_CS)
class(Michigan_CS) #xts y zoo, lo cual es estándar en objeto xts.
frequency(Michigan_CS)
is.regular(Michigan_CS, strict = TRUE)
head(Michigan_CS)
plot(Michigan_CS)
head(US_indicators)
str(US_indicators)
US_indicators_xts = xts(x = US_indicators[,c("Vehicle Sales",
"Unemployment Rate")],frequency = 12,
order.by = US_indicators$Date)
head(US_indicators_xts)
ts_info(US_indicators_xts)
frequency(US_indicators_xts)
class(US_indicators_xts)
periodicity(US_indicators_xts) # Así podemos saber la periodicidad, si es diaria, mensual...
tclass(US_indicators_xts) # Así podemos saber la clase del índice
# Retornando a los datos de Michigan
periodicity(Michigan_CS)
tclass(Michigan_CS)
tformat(Michigan_CS) <- "%m-%d-%Y" # Así cambiamos el formato de los índices
head(Michigan_CS)
Colcap   = read_excel("Datos históricos COLCAP-3.xlsx")
TsColCap = xts(Colcap$Ultimo, order.by = as.Date(Colcap$Fecha, "%Y-%m-%d"))
plot(TsColCap)
acf(TsColCap)
str(TsColCap)
library(tsibble)
library(dplyr)
library(fpp3) # Esta librería llama ya a tsibble y dplyr
US_tsibble <- US_indicators %>%
mutate(Mes = yearmonth(Date)) %>%
as_tsibble(index = Mes)
US_tsibble %>%
autoplot(`Vehicle Sales`)
US_tsibble %>%
autoplot(`Vehicle Sales`) +
labs(y="Ventas de vehículos",x="Mes") +
theme_light()
US_tsibble %>%
ACF(`Vehicle Sales`) %>%
autoplot() +
labs(title="acf de la venta de vehículos")
US_tsibble %>%
ACF(`Vehicle Sales`,type="partial") %>%
autoplot() +
labs(title="pacf de la venta de vehículos")
library(forecast)
Colcap_msts = msts(Colcap$Ultimo, seasonal.periods=c(7,365.25), start=c(2016,2,10))
plot(Colcap_msts)
TSstudio::ts_plot(sercamrelint,title="",slider=TRUE)
TSstudio::ts_cor(sercamrelint) # Funciones de autocorrelación
library(dygraphs)
dygraph(sercamrelint,main="Gráfico de Retorno Interés Anual", ylab="Cambios relativos del tipo de interés anual")%>% dyRangeSelector()
library(lubridate)
# Formato Date
fecha <- as.Date("2014-5-12")
fecha
class(fecha)
# Formato POSIXct/POSIXlt
hora_ct <- as.POSIXct("2014-5-12 20:05:35", tz = "EST")
hora_ct
class(hora_ct)
url <-
"https://github.com/PacktPublishing/Hands-On-Time-Series-Analysis-with-R/raw/master/Chapter02/dates_formats.csv"
dates_df <- read.csv(url, stringsAsFactors = FALSE)
str(dates_df)
dates_df$Japanese_format_new <- as.Date(dates_df$Japanese_format)
head(dates_df[, c("Japanese_format", "Japanese_format_new")])
identical(dates_df$Japanese_format, dates_df$Japanese_format_new)
class(dates_df$Japanese_format)  # Los diferentes formatos uno caractér y el otro fecha
class(dates_df$Japanese_format_new)
head(dates_df$US_format)
dates_df$US_format_new <- as.Date(dates_df$US_format, format = "%m/%d/%Y")
head(dates_df$US_format_new)
head(dates_df$US_long_format)
dates_df$US_long_format_new <- as.Date(dates_df$US_long_format, format =
"%A, %B %d, %Y")
head(dates_df$US_long_format_new)
class(dates_df$US_long_format_new)
time_str <- "2018-12-31 23:59:59"
class(time_str)
time_posix_ct1 <- as.POSIXct(time_str)
class(time_posix_ct1)
#Comparemos los dos objetos
time_str
time_posix_ct1
time_numeric <- 1546318799   #El valor numérico representa el número de segundos trasncurridos desde el punto de origen
class(time_numeric)
time_posix_ct2 <- as.POSIXct(time_numeric, origin = "1970-01-01")
print(c(time_posix_ct1, time_posix_ct2))
identical(time_posix_ct1, time_posix_ct2)
####Note que los ejemplos anteriores no requieren el paso de reformateo
#Monday, December 31,    PM   %A, %B %d,  %p  PM
Sys.setlocale(locale="en_US.UTF-8")
time_US_str <- "Monday, December 31, 2018 11:59:58 PM"
time_posix_ct3 <- as.POSIXct(time_US_str, format = "%A, %B %d, %Y %I:%M:%S %p")
time_posix_ct3
identical(time_posix_ct1, time_posix_ct2,time_posix_ct3)
daily_index <- seq.Date(from = as.Date("2016-01-01"), # Fecha inicial
to = as.Date("2018-12-31"), # Fecha final
by = "day") # Intervalos de tiempo
head(daily_index)
daily_3_index <- seq.Date(from = as.Date("2016-01-01"),
to = as.Date("2018-12-31"),
by = "3 days")
head(daily_3_index)
hourly_index <- seq.POSIXt(from = as.POSIXct("2018-06-01"), by = "hours",
length.out = 48)
str(hourly_index)
head(hourly_index)
tail(hourly_index)
library(lubridate)
time_US_str <- "Monday, December 31, 2018 11:59:59 PM"
class(time_US_str)
time_US_str
# Y lo convertimos en un objeto POSIXct
time_base <- as.POSIXct(time_US_str,
format = "%A, %B %d, %Y %I:%M:%S %p")
class(time_base)
time_base
Sys.setlocale(locale="es_ES.UTF-8")   # Establece fecha en español
#Sys.setlocale(locale="en_US.UTF-8")  # Establece fecha en inglés
time_Col_str="Lunes, Diciembre 31, 2018 11:59:59 PM"
time_Col_base <- as.POSIXct(time_Col_str,format = "%A, %B %d, %Y %I:%M:%S %p")
time_Col_base
class(time_Col_base)
time_lubridate <- mdy_hms(time_US_str, tz = "EST")
class(time_lubridate)
time_lubridate
yday(time_lubridate) # Posición del día en el año
qday(time_lubridate) # Posición de día en el trimestre
day(time_lubridate)  # Posición de día en el mes
library(tidyverse)
library(tidyquant)
library(TSstudio)
library(SLBDD)
install.packages("SLBDD")
data("temperatures")
head(temperatures)
libarry(SLBDD)
library(SLBDD)
install.packages("~/Downloads/SLBDD_0.0.4.tar", repos = NULL)
install.packages("~/Downloads/SLBDD_0.0.4.tar", repos = NULL)
install.packages("~/Downloads/SLBDD_0.0.4.tar")
library(SLBDD)
library(ggfortify)
autoplot(MultTsTemp)
data("temperatures")
load("temperatures.rds")
readRDS("temperatures.rds")
data("temperatures")
temperatures
tempetatures<-readRDS("temperatures.rds")
#data("temperatures")
head(temperatures)
temperatures<-readRDS("temperatures.rds")
#data("temperatures")
head(temperatures)
str(temperatures)
MultTsTemp = xts(temperatures[2:4],order.by=as.Date(ISOdate(temperatures$year,1,1)))
plot(MultTsTemp,legend.loc='bottomright')
library(tidyverse)
library(tidyquant)
library(TSstudio)
#library(SLBDD)
library(timetk)
library(fable)
temperatures<-readRDS("temperatures.rds")
#data("temperatures")
head(temperatures)
str(temperatures)
MultTsTemp = xts(temperatures[2:4],order.by=as.Date(ISOdate(temperatures$year,1,1)))
plot(MultTsTemp,legend.loc='bottomright')
par(mfrow = c(3 , 1))
plot(MultTsTemp[,1], main = "Europa")
temperatures<-readRDS("temperatures.rds")
#data("temperatures")
head(temperatures)
str(temperatures)
MultTsTemp = xts(temperatures[2:4],order.by=as.Date(ISOdate(temperatures$year,1,1)))
plot(MultTsTemp,legend.loc='bottomright')
par(mfrow = c(3 , 1))
plot(MultTsTemp[,1], main = "Europa")
temperatures<-readRDS("temperatures.rds")
#data("temperatures")
head(temperatures)
str(temperatures)
MultTsTemp = xts(temperatures[2:4],order.by=as.Date(ISOdate(temperatures$year,1,1)))
plot(MultTsTemp,legend.loc='bottomright')
par(mfrow = c(3 , 1))
plot(MultTsTemp[,1], main = "Europa")
library(ggfortify)
autoplot(MultTsTemp)
library(timeSeries)
data("Stockindexes99world")
ts_data_stocks = timeSeries(Stockindexes99world[2:100],Stockindexes99world$Date)
#data("Stockindexes99world")
Stockindexes99world<-readRDS("Stockindexes99world")
#data("Stockindexes99world")
Stockindexes99world<-readRDS("Stockindexes99world.rds")
ts_data_stocks = timeSeries(Stockindexes99world[2:100],Stockindexes99world$Date)
str(ts_data_stocks)
plot(ts_data_stocks,plot.type="s")
plot(ts_data_stocks[,1:6], plot.type="m")
#data("clothing")
clothing<-readRDS("clothing")
#data("clothing")
clothing<-readRDS("clothing.rds")
head(clothing)
# Creamos los índices o marcas de tiempo
daily_index = seq.Date(from = as.Date("2008-01-01"),to = as.Date("2012-12-16"),by = "day")
df_ventas = data.frame(clothing,daily_index)
# Creamos el objeto tsibble:
tsibble_ventas <- as_tsibble(df_ventas,index=daily_index)
tsibble_ventas %>%
pivot_longer(c(Province_1,Province_2,Province_3,Province_4,Province_5,
Province_6,Province_7,Province_8), names_to="Series") %>%
autoplot(value) +
labs(y = "Ventas Provincias log")
temperatures<-readRDS("temperatures.rds")
#data("temperatures")
head(temperatures)
str(temperatures)
MultTsTemp = xts(temperatures[2:4],order.by=as.Date(ISOdate(temperatures$year,1,1)))
plot(MultTsTemp,legend.loc='bottomright')
par(mfrow = c(3 , 1))
plot(MultTsTemp[,1], main = "Europa")
